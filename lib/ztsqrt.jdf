extern "C" %{
/*
 * Copyright (c) 2010-2013 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 * Copyright (c) 2013      Inria. All rights reserved.
 * $COPYRIGHT
 *
 *
 * @precisions normal z -> s d c
 *
 */
#include <lapacke.h>
#include "dplasma/lib/dplasmajdf.h"
#include "data_dist/matrix/matrix.h"

%}

dataA2 [type = "dague_ddesc_t *"]
dataA1 [type = "dague_ddesc_t *" aligned=dataA2]
dataT  [type = "dague_ddesc_t *" aligned=dataA2]
p_work [type = "dague_memory_pool_t *" size = "(sizeof(dague_complex64_t)*descT.mb*descT.mb)"]

descA1 [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataA1)"]
descA2 [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataA2)"]
descT  [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataT)"]
minMNT [type = "int" hidden=on default = "dplasma_imin(descA2.nt, ((descA2.m+descA2.nb-1)/descA2.nb))-1"]

ztsqrt(k)
  /* Execution space */
  k = 0 .. descA2.nt-1

  : dataA2(0, k)

  RW   A1 <- (0 == k) ? dataA1(0, k) : A1 ztsmqr(k-1, k)
          -> dataA1(0, k)

  RW   A2 <- (0 == k) ? dataA2(0, k) : A2 ztsmqr(k-1, k)
          -> (k < (descA2.nt-1)) ? V ztsmqr(k, k+1 ..  descA2.nt-1)
          -> dataA2(0, k)

  RW    T <- dataT(0, k)                                               [type = LITTLE_T]
          -> dataT(0, k)      [type = LITTLE_T]
          -> (k < (descA2.nt-1)) ? T ztsmqr(k, k+1 ..  descA2.nt-1) [type = LITTLE_T]

BODY
{
    dague_complex64_t *lA1 = (dague_complex64_t*)A1;
    int tempkn = ((k)==(descA2.nt-1)) ? (descA2.n-(k*descA2.nb)) : descA2.nb;
    int ldak = BLKLDD( descA2, k );

    printlog("CORE_ztsqrt(%d, %d)\n"
             "\t(tempmm, tempkn, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, p_elem_A, p_elem_B)\n",
             k, k, k, k, T, k, k, A1, k, k, A2);

#if !defined(DAGUE_DRY_RUN)
    printf("ldak %d", ldak);

    void *p_elem_tau  = dague_private_memory_pop( p_work );
    void *p_elem_work = dague_private_memory_pop( p_work );

    CORE_ztsqrt(descA2.m, tempkn, descA2.nb,
                lA1+k*descA2.nb /* dataA(k,k) */, ldak,
                A2 /* dataA(m,k) */, ldak,
                T  /* dataT(m,k) */, descT.mb,
                p_elem_tau, p_elem_work );

    dague_private_memory_push( p_work, p_elem_tau  );
    dague_private_memory_push( p_work, p_elem_work );

#endif  /* !defined(DAGUE_DRY_RUN) */
}
END

ztsmqr(k, n)
  /* Execution space */
  k = 0   .. descA2.nt-1
  n = k+1 .. descA2.nt-1

  : dataA2(0,n)

  READ  V <- A2 ztsqrt(k)
  READ  T <- T ztsqrt(k)             [type = LITTLE_T]

  RW   A1 <- dataA1(0, n)
          -> ( n == k+1 ) ? A1 ztsqrt(k+1)

  RW   A2 <- (k == 0) ? dataA2(0, n) : A2 ztsmqr(k-1, n)
          -> ( n == k+1 ) ? A2 ztsqrt(k+1)
          -> ( n >  k+1 ) ? A2 ztsmqr(k+1, n)

BODY
{
    dague_complex64_t *lA1 = (dague_complex64_t*)A1;
    int tempnn = ((n)==(descA2.nt-1)) ? (descA2.n-(n*descA2.nb)) : descA2.nb;
    int ldak = BLKLDD( descA2, k );

        printlog("CORE_ztsmqr(%d, %d, %d)\n"
             "\t(PlasmaLeft, PlasmaConjTrans, descA.mb, tempnn, tempmm, tempnn, descA.nb, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, p_elem_A, ldwork)\n",
             k, k, n, k, n, A1, k, n, A2, k, k, V, k, k, T);

#if !defined(DAGUE_DRY_RUN)
    void *p_elem_W = dague_private_memory_pop( p_work );

    CORE_ztsmqr(PlasmaLeft, PlasmaConjTrans,
                descA2.nb, tempnn, descA2.m, tempnn, descA2.nb, descA2.nb,
                lA1 + k*descA1.nb /* dataA(k,n) */, ldak,
                A2 /* dataA(m,n) */,               ldak,
                V  /* dataA(m,k) */,               ldak,
                T  /* dataT(m,k) */,               descT.mb,
                p_elem_W, descA2.nb );

    dague_private_memory_push( p_work, p_elem_W );

#endif  /* !defined(DAGUE_DRY_RUN) */
}
END
